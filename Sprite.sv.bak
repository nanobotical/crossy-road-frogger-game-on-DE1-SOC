module Sprite (clk, reset, move_up, move_down, move_left, move_right, grid);

    input  logic clk, reset;
    input  logic move_up, move_down, move_left, move_right;
    output logic [15:0][15:0] grid;

    typedef enum logic [3:0] {
        POS_0,  POS_1,  POS_2,  POS_3,
        POS_4,  POS_5,  POS_6,  POS_7,
        POS_8,  POS_9,  POS_10, POS_11,
        POS_12, POS_13, POS_14, POS_15
    } state_t;

    state_t row_state, next_row_state;
    state_t col_state, next_col_state;

    logic [15:0] row_mask, col_mask;

    // FSM: Row movement logic
    always_comb begin
        next_row_state = row_state;
        if (move_up    && row_state > POS_0)   next_row_state = state_t'(row_state - 1);
        else if (move_down && row_state < POS_15) next_row_state = state_t'(row_state + 1);
    end

    // FSM: Column movement logic
    always_comb begin
        next_col_state = col_state;
        if (move_left  && col_state > POS_0)   next_col_state = state_t'(col_state - 1);
        else if (move_right && col_state < POS_15) next_col_state = state_t'(col_state + 1);
    end

    // Register state
    always_ff @(posedge clk) begin
        if (reset) begin
            row_state <= POS_0;
            col_state <= POS_7;
        end else begin
            row_state <= next_row_state;
            col_state <= next_col_state;
        end
    end

    // row_mask based on present_row
    always_comb begin
        case (row_state)
            POS_0:  row_mask = 16'b1000_0000_0000_0000;
            POS_1:  row_mask = 16'b0100_0000_0000_0000;
            POS_2:  row_mask = 16'b0010_0000_0000_0000;
            POS_3:  row_mask = 16'b0001_0000_0000_0000;
            POS_4:  row_mask = 16'b0000_1000_0000_0000;
            POS_5:  row_mask = 16'b0000_0100_0000_0000;
            POS_6:  row_mask = 16'b0000_0010_0000_0000;
            POS_7:  row_mask = 16'b0000_0001_0000_0000;
            POS_8:  row_mask = 16'b0000_0000_1000_0000;
            POS_9:  row_mask = 16'b0000_0000_0100_0000;
            POS_10: row_mask = 16'b0000_0000_0010_0000;
            POS_11: row_mask = 16'b0000_0000_0001_0000;
            POS_12: row_mask = 16'b0000_0000_0000_1000;
            POS_13: row_mask = 16'b0000_0000_0000_0100;
            POS_14: row_mask = 16'b0000_0000_0000_0010;
            POS_15: row_mask = 16'b0000_0000_0000_0001;
            default: row_mask = 16'd0;
        endcase
    end

    // col_mask based on present_col
    always_comb begin
        case (col_state)
            POS_0:  col_mask = 16'b1000_0000_0000_0000;
            POS_1:  col_mask = 16'b0100_0000_0000_0000;
            POS_2:  col_mask = 16'b0010_0000_0000_0000;
            POS_3:  col_mask = 16'b0001_0000_0000_0000;
            POS_4:  col_mask = 16'b0000_1000_0000_0000;
            POS_5:  col_mask = 16'b0000_0100_0000_0000;
            POS_6:  col_mask = 16'b0000_0010_0000_0000;
            POS_7:  col_mask = 16'b0000_0001_0000_0000;
            POS_8:  col_mask = 16'b0000_0000_1000_0000;
            POS_9:  col_mask = 16'b0000_0000_0100_0000;
            POS_10: col_mask = 16'b0000_0000_0010_0000;
            POS_11: col_mask = 16'b0000_0000_0001_0000;
            POS_12: col_mask = 16'b0000_0000_0000_1000;
            POS_13: col_mask = 16'b0000_0000_0000_0100;
            POS_14: col_mask = 16'b0000_0000_0000_0010;
            POS_15: col_mask = 16'b0000_0000_0000_0001;
            default: col_mask = 16'd0;
        endcase
    end

    // grid update
    always_comb begin
        grid = '{default: 16'd0};
        for (int i = 0; i < 16; i++) begin
            if (row_mask[i]) grid[i] = col_mask;
        end
    end

endmodule

module Sprite_testbench;

    logic clk, reset;
    logic move_up, move_down, move_left, move_right;
    logic [15:0][15:0] grid;

    // Instantiate DUT
    Sprite dut (
        .clk(clk),
        .reset(reset),
        .move_up(move_up),
        .move_down(move_down),
        .move_left(move_left),
        .move_right(move_right),
        .grid(grid)
    );

    // Clock generation: 100 time unit period
    parameter CLOCK_PERIOD = 100;
    initial clk = 0;
    always #(CLOCK_PERIOD / 2) clk = ~clk;

    // Task to apply one-cycle directional input
    task move(
        input logic up, down, left, right
    );
        move_up    = up;
        move_down  = down;
        move_left  = left;
        move_right = right;
        @(posedge clk);
        move_up    = 0;
        move_down  = 0;
        move_left  = 0;
        move_right = 0;
    endtask

    // Print grid (active bit only)
    function void print_grid();
        int r, c;
        for (r = 0; r < 16; r++) begin
            for (c = 15; c >= 0; c--) begin
                $write("%0d", grid[r][c]);
            end
            $write("  // row %0d", r);
            if (|grid[r])
                $write(" <-- ACTIVE");
            $display("");
        end
        $display("----");
    endfunction

    // Stimulus
    initial begin
        // Initial values
        move_up = 0; move_down = 0; move_left = 0; move_right = 0;
        reset = 1; @(posedge clk);
        reset = 0; @(posedge clk);

        $display("Initial state:");
        print_grid();

        // Move down 3x
        move(0,1,0,0); print_grid();
        move(0,1,0,0); print_grid();
        move(0,1,0,0); print_grid();

        // Move right 2x
        move(0,0,0,1); print_grid();
        move(0,0,0,1); print_grid();

        // Move up 1x
        move(1,0,0,0); print_grid();

        // Move left 2x
        move(0,0,1,0); print_grid();
        move(0,0,1,0); print_grid();

        $stop;
    end

endmodule